/*
    robTreeModel is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    robTreeModel is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with robTreeModel.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.21.0

#include <stan/model/model_header.hpp>

namespace model_strain_multiplier_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_strain_multiplier");
    reader.add_event(241, 239, "end", "model_strain_multiplier");
    return reader;
}

class model_strain_multiplier
  : public stan::model::model_base_crtp<model_strain_multiplier> {
private:
        int n_dates;
        int n_strains;
        std::vector<std::vector<int> > cases;
        int data_freq;
        std::vector<int> seed_start_time;
        std::vector<int> seed_end_time;
        int n_jumps;
        std::vector<int> jump_times;
        double generation_mean;
        double generation_sd;
        int generation_max;
        double test_mean;
        double test_sd;
        double ascertainment_factor;
        double prior_R0_min;
        double prior_R0_max;
        double prior_dR_sd_min;
        double prior_dR_sd_max;
        double prior_phi_od_max;
        double prior_jump_up_max;
        double prior_jump_down_max;
        std::vector<double> prior_daily_seed_max;
        std::vector<double> prior_strain_multipliers_min;
        std::vector<double> prior_strain_multipliers_max;
        int multiply_strain_multipliers;
        int mask_cases_less_than;
        int n_inf;
        int n_R;
        int n_strain_multipliers;
        int test_data_max;
        std::vector<double> inf0_data;
        std::vector<int> idx_dp;
        std::vector<double> generation_time;
        std::vector<double> test_time;
        std::vector<double> test_time_data;
        double g_alpha;
        double g_beta;
        double t_alpha;
        double t_beta;
        vector_d ones_dates;
        std::vector<int> seed_start_time_adj;
        std::vector<int> seed_end_time_adj;
        double prior_daily_seed_max_max;
        std::vector<int> n_used_data;
        std::vector<std::vector<int> > used_data;
public:
    model_strain_multiplier(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : model_base_crtp(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_strain_multiplier(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : model_base_crtp(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        typedef double local_scalar_t__;

        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_strain_multiplier_namespace::model_strain_multiplier";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            // initialize data block variables from context__
            current_statement_begin__ = 3;
            context__.validate_dims("data initialization", "n_dates", "int", context__.to_vec());
            n_dates = int(0);
            vals_i__ = context__.vals_i("n_dates");
            pos__ = 0;
            n_dates = vals_i__[pos__++];
            check_greater_or_equal(function__, "n_dates", n_dates, 0);

            current_statement_begin__ = 4;
            context__.validate_dims("data initialization", "n_strains", "int", context__.to_vec());
            n_strains = int(0);
            vals_i__ = context__.vals_i("n_strains");
            pos__ = 0;
            n_strains = vals_i__[pos__++];
            check_greater_or_equal(function__, "n_strains", n_strains, 1);

            current_statement_begin__ = 5;
            validate_non_negative_index("cases", "n_dates", n_dates);
            validate_non_negative_index("cases", "n_strains", n_strains);
            context__.validate_dims("data initialization", "cases", "int", context__.to_vec(n_dates,n_strains));
            cases = std::vector<std::vector<int> >(n_dates, std::vector<int>(n_strains, int(0)));
            vals_i__ = context__.vals_i("cases");
            pos__ = 0;
            size_t cases_k_0_max__ = n_dates;
            size_t cases_k_1_max__ = n_strains;
            for (size_t k_1__ = 0; k_1__ < cases_k_1_max__; ++k_1__) {
                for (size_t k_0__ = 0; k_0__ < cases_k_0_max__; ++k_0__) {
                    cases[k_0__][k_1__] = vals_i__[pos__++];
                }
            }
            size_t cases_i_0_max__ = n_dates;
            size_t cases_i_1_max__ = n_strains;
            for (size_t i_0__ = 0; i_0__ < cases_i_0_max__; ++i_0__) {
                for (size_t i_1__ = 0; i_1__ < cases_i_1_max__; ++i_1__) {
                    check_greater_or_equal(function__, "cases[i_0__][i_1__]", cases[i_0__][i_1__], 0);
                }
            }

            current_statement_begin__ = 6;
            context__.validate_dims("data initialization", "data_freq", "int", context__.to_vec());
            data_freq = int(0);
            vals_i__ = context__.vals_i("data_freq");
            pos__ = 0;
            data_freq = vals_i__[pos__++];
            check_greater_or_equal(function__, "data_freq", data_freq, 0);

            current_statement_begin__ = 9;
            validate_non_negative_index("seed_start_time", "n_strains", n_strains);
            context__.validate_dims("data initialization", "seed_start_time", "int", context__.to_vec(n_strains));
            seed_start_time = std::vector<int>(n_strains, int(0));
            vals_i__ = context__.vals_i("seed_start_time");
            pos__ = 0;
            size_t seed_start_time_k_0_max__ = n_strains;
            for (size_t k_0__ = 0; k_0__ < seed_start_time_k_0_max__; ++k_0__) {
                seed_start_time[k_0__] = vals_i__[pos__++];
            }
            size_t seed_start_time_i_0_max__ = n_strains;
            for (size_t i_0__ = 0; i_0__ < seed_start_time_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "seed_start_time[i_0__]", seed_start_time[i_0__], 0);
            }

            current_statement_begin__ = 10;
            validate_non_negative_index("seed_end_time", "n_strains", n_strains);
            context__.validate_dims("data initialization", "seed_end_time", "int", context__.to_vec(n_strains));
            seed_end_time = std::vector<int>(n_strains, int(0));
            vals_i__ = context__.vals_i("seed_end_time");
            pos__ = 0;
            size_t seed_end_time_k_0_max__ = n_strains;
            for (size_t k_0__ = 0; k_0__ < seed_end_time_k_0_max__; ++k_0__) {
                seed_end_time[k_0__] = vals_i__[pos__++];
            }
            size_t seed_end_time_i_0_max__ = n_strains;
            for (size_t i_0__ = 0; i_0__ < seed_end_time_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "seed_end_time[i_0__]", seed_end_time[i_0__], 0);
            }

            current_statement_begin__ = 13;
            context__.validate_dims("data initialization", "n_jumps", "int", context__.to_vec());
            n_jumps = int(0);
            vals_i__ = context__.vals_i("n_jumps");
            pos__ = 0;
            n_jumps = vals_i__[pos__++];
            check_greater_or_equal(function__, "n_jumps", n_jumps, 0);

            current_statement_begin__ = 14;
            validate_non_negative_index("jump_times", "n_jumps", n_jumps);
            context__.validate_dims("data initialization", "jump_times", "int", context__.to_vec(n_jumps));
            jump_times = std::vector<int>(n_jumps, int(0));
            vals_i__ = context__.vals_i("jump_times");
            pos__ = 0;
            size_t jump_times_k_0_max__ = n_jumps;
            for (size_t k_0__ = 0; k_0__ < jump_times_k_0_max__; ++k_0__) {
                jump_times[k_0__] = vals_i__[pos__++];
            }
            size_t jump_times_i_0_max__ = n_jumps;
            for (size_t i_0__ = 0; i_0__ < jump_times_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "jump_times[i_0__]", jump_times[i_0__], 0);
            }

            current_statement_begin__ = 17;
            context__.validate_dims("data initialization", "generation_mean", "double", context__.to_vec());
            generation_mean = double(0);
            vals_r__ = context__.vals_r("generation_mean");
            pos__ = 0;
            generation_mean = vals_r__[pos__++];

            current_statement_begin__ = 18;
            context__.validate_dims("data initialization", "generation_sd", "double", context__.to_vec());
            generation_sd = double(0);
            vals_r__ = context__.vals_r("generation_sd");
            pos__ = 0;
            generation_sd = vals_r__[pos__++];

            current_statement_begin__ = 19;
            context__.validate_dims("data initialization", "generation_max", "int", context__.to_vec());
            generation_max = int(0);
            vals_i__ = context__.vals_i("generation_max");
            pos__ = 0;
            generation_max = vals_i__[pos__++];

            current_statement_begin__ = 20;
            context__.validate_dims("data initialization", "test_mean", "double", context__.to_vec());
            test_mean = double(0);
            vals_r__ = context__.vals_r("test_mean");
            pos__ = 0;
            test_mean = vals_r__[pos__++];

            current_statement_begin__ = 21;
            context__.validate_dims("data initialization", "test_sd", "double", context__.to_vec());
            test_sd = double(0);
            vals_r__ = context__.vals_r("test_sd");
            pos__ = 0;
            test_sd = vals_r__[pos__++];

            current_statement_begin__ = 22;
            context__.validate_dims("data initialization", "ascertainment_factor", "double", context__.to_vec());
            ascertainment_factor = double(0);
            vals_r__ = context__.vals_r("ascertainment_factor");
            pos__ = 0;
            ascertainment_factor = vals_r__[pos__++];

            current_statement_begin__ = 25;
            context__.validate_dims("data initialization", "prior_R0_min", "double", context__.to_vec());
            prior_R0_min = double(0);
            vals_r__ = context__.vals_r("prior_R0_min");
            pos__ = 0;
            prior_R0_min = vals_r__[pos__++];

            current_statement_begin__ = 26;
            context__.validate_dims("data initialization", "prior_R0_max", "double", context__.to_vec());
            prior_R0_max = double(0);
            vals_r__ = context__.vals_r("prior_R0_max");
            pos__ = 0;
            prior_R0_max = vals_r__[pos__++];

            current_statement_begin__ = 27;
            context__.validate_dims("data initialization", "prior_dR_sd_min", "double", context__.to_vec());
            prior_dR_sd_min = double(0);
            vals_r__ = context__.vals_r("prior_dR_sd_min");
            pos__ = 0;
            prior_dR_sd_min = vals_r__[pos__++];

            current_statement_begin__ = 28;
            context__.validate_dims("data initialization", "prior_dR_sd_max", "double", context__.to_vec());
            prior_dR_sd_max = double(0);
            vals_r__ = context__.vals_r("prior_dR_sd_max");
            pos__ = 0;
            prior_dR_sd_max = vals_r__[pos__++];

            current_statement_begin__ = 29;
            context__.validate_dims("data initialization", "prior_phi_od_max", "double", context__.to_vec());
            prior_phi_od_max = double(0);
            vals_r__ = context__.vals_r("prior_phi_od_max");
            pos__ = 0;
            prior_phi_od_max = vals_r__[pos__++];

            current_statement_begin__ = 30;
            context__.validate_dims("data initialization", "prior_jump_up_max", "double", context__.to_vec());
            prior_jump_up_max = double(0);
            vals_r__ = context__.vals_r("prior_jump_up_max");
            pos__ = 0;
            prior_jump_up_max = vals_r__[pos__++];

            current_statement_begin__ = 31;
            context__.validate_dims("data initialization", "prior_jump_down_max", "double", context__.to_vec());
            prior_jump_down_max = double(0);
            vals_r__ = context__.vals_r("prior_jump_down_max");
            pos__ = 0;
            prior_jump_down_max = vals_r__[pos__++];

            current_statement_begin__ = 32;
            validate_non_negative_index("prior_daily_seed_max", "n_strains", n_strains);
            context__.validate_dims("data initialization", "prior_daily_seed_max", "double", context__.to_vec(n_strains));
            prior_daily_seed_max = std::vector<double>(n_strains, double(0));
            vals_r__ = context__.vals_r("prior_daily_seed_max");
            pos__ = 0;
            size_t prior_daily_seed_max_k_0_max__ = n_strains;
            for (size_t k_0__ = 0; k_0__ < prior_daily_seed_max_k_0_max__; ++k_0__) {
                prior_daily_seed_max[k_0__] = vals_r__[pos__++];
            }

            current_statement_begin__ = 33;
            validate_non_negative_index("prior_strain_multipliers_min", "(n_strains - 1)", (n_strains - 1));
            context__.validate_dims("data initialization", "prior_strain_multipliers_min", "double", context__.to_vec((n_strains - 1)));
            prior_strain_multipliers_min = std::vector<double>((n_strains - 1), double(0));
            vals_r__ = context__.vals_r("prior_strain_multipliers_min");
            pos__ = 0;
            size_t prior_strain_multipliers_min_k_0_max__ = (n_strains - 1);
            for (size_t k_0__ = 0; k_0__ < prior_strain_multipliers_min_k_0_max__; ++k_0__) {
                prior_strain_multipliers_min[k_0__] = vals_r__[pos__++];
            }

            current_statement_begin__ = 34;
            validate_non_negative_index("prior_strain_multipliers_max", "(n_strains - 1)", (n_strains - 1));
            context__.validate_dims("data initialization", "prior_strain_multipliers_max", "double", context__.to_vec((n_strains - 1)));
            prior_strain_multipliers_max = std::vector<double>((n_strains - 1), double(0));
            vals_r__ = context__.vals_r("prior_strain_multipliers_max");
            pos__ = 0;
            size_t prior_strain_multipliers_max_k_0_max__ = (n_strains - 1);
            for (size_t k_0__ = 0; k_0__ < prior_strain_multipliers_max_k_0_max__; ++k_0__) {
                prior_strain_multipliers_max[k_0__] = vals_r__[pos__++];
            }

            current_statement_begin__ = 37;
            context__.validate_dims("data initialization", "multiply_strain_multipliers", "int", context__.to_vec());
            multiply_strain_multipliers = int(0);
            vals_i__ = context__.vals_i("multiply_strain_multipliers");
            pos__ = 0;
            multiply_strain_multipliers = vals_i__[pos__++];
            check_greater_or_equal(function__, "multiply_strain_multipliers", multiply_strain_multipliers, 0);
            check_less_or_equal(function__, "multiply_strain_multipliers", multiply_strain_multipliers, 1);

            current_statement_begin__ = 38;
            context__.validate_dims("data initialization", "mask_cases_less_than", "int", context__.to_vec());
            mask_cases_less_than = int(0);
            vals_i__ = context__.vals_i("mask_cases_less_than");
            pos__ = 0;
            mask_cases_less_than = vals_i__[pos__++];
            check_greater_or_equal(function__, "mask_cases_less_than", mask_cases_less_than, 0);


            // initialize transformed data variables
            current_statement_begin__ = 43;
            n_inf = int(0);
            stan::math::fill(n_inf, std::numeric_limits<int>::min());

            current_statement_begin__ = 44;
            n_R = int(0);
            stan::math::fill(n_R, std::numeric_limits<int>::min());

            current_statement_begin__ = 45;
            n_strain_multipliers = int(0);
            stan::math::fill(n_strain_multipliers, std::numeric_limits<int>::min());

            current_statement_begin__ = 46;
            test_data_max = int(0);
            stan::math::fill(test_data_max, std::numeric_limits<int>::min());

            current_statement_begin__ = 47;
            validate_non_negative_index("inf0_data", "n_strains", n_strains);
            inf0_data = std::vector<double>(n_strains, double(0));
            stan::math::fill(inf0_data, DUMMY_VAR__);

            current_statement_begin__ = 48;
            validate_non_negative_index("idx_dp", "n_dates", n_dates);
            idx_dp = std::vector<int>(n_dates, int(0));
            stan::math::fill(idx_dp, std::numeric_limits<int>::min());

            current_statement_begin__ = 49;
            validate_non_negative_index("generation_time", "generation_max", generation_max);
            generation_time = std::vector<double>(generation_max, double(0));
            stan::math::fill(generation_time, DUMMY_VAR__);

            current_statement_begin__ = 50;
            validate_non_negative_index("test_time", "generation_max", generation_max);
            test_time = std::vector<double>(generation_max, double(0));
            stan::math::fill(test_time, DUMMY_VAR__);

            current_statement_begin__ = 51;
            validate_non_negative_index("test_time_data", "(generation_max + data_freq)", (generation_max + data_freq));
            test_time_data = std::vector<double>((generation_max + data_freq), double(0));
            stan::math::fill(test_time_data, DUMMY_VAR__);

            current_statement_begin__ = 52;
            g_alpha = double(0);
            stan::math::fill(g_alpha, DUMMY_VAR__);
            stan::math::assign(g_alpha,(((generation_mean * generation_mean) / generation_sd) / generation_sd));

            current_statement_begin__ = 53;
            g_beta = double(0);
            stan::math::fill(g_beta, DUMMY_VAR__);
            stan::math::assign(g_beta,((generation_mean / generation_sd) / generation_sd));

            current_statement_begin__ = 54;
            t_alpha = double(0);
            stan::math::fill(t_alpha, DUMMY_VAR__);
            stan::math::assign(t_alpha,(((test_mean * test_mean) / test_sd) / test_sd));

            current_statement_begin__ = 55;
            t_beta = double(0);
            stan::math::fill(t_beta, DUMMY_VAR__);
            stan::math::assign(t_beta,((test_mean / test_sd) / test_sd));

            current_statement_begin__ = 56;
            validate_non_negative_index("ones_dates", "n_dates", n_dates);
            ones_dates = Eigen::Matrix<double, Eigen::Dynamic, 1>(n_dates);
            stan::math::fill(ones_dates, DUMMY_VAR__);

            current_statement_begin__ = 57;
            validate_non_negative_index("seed_start_time_adj", "n_strains", n_strains);
            seed_start_time_adj = std::vector<int>(n_strains, int(0));
            stan::math::fill(seed_start_time_adj, std::numeric_limits<int>::min());

            current_statement_begin__ = 58;
            validate_non_negative_index("seed_end_time_adj", "n_strains", n_strains);
            seed_end_time_adj = std::vector<int>(n_strains, int(0));
            stan::math::fill(seed_end_time_adj, std::numeric_limits<int>::min());

            current_statement_begin__ = 59;
            prior_daily_seed_max_max = double(0);
            stan::math::fill(prior_daily_seed_max_max, DUMMY_VAR__);

            current_statement_begin__ = 60;
            validate_non_negative_index("n_used_data", "n_strains", n_strains);
            n_used_data = std::vector<int>(n_strains, int(0));
            stan::math::fill(n_used_data, std::numeric_limits<int>::min());

            current_statement_begin__ = 61;
            validate_non_negative_index("used_data", "n_dates", n_dates);
            validate_non_negative_index("used_data", "n_strains", n_strains);
            used_data = std::vector<std::vector<int> >(n_dates, std::vector<int>(n_strains, int(0)));
            stan::math::fill(used_data, std::numeric_limits<int>::min());

            // execute transformed data statements
            current_statement_begin__ = 64;
            for (int t = 1; t <= generation_max; ++t) {

                current_statement_begin__ = 65;
                stan::model::assign(generation_time, 
                            stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                            stan::math::exp(gamma_log(t, g_alpha, g_beta)), 
                            "assigning variable generation_time");
                current_statement_begin__ = 66;
                stan::model::assign(test_time, 
                            stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                            stan::math::exp(gamma_log(t, t_alpha, t_beta)), 
                            "assigning variable test_time");
            }
            current_statement_begin__ = 70;
            stan::math::assign(test_data_max, (generation_max + data_freq));
            current_statement_begin__ = 71;
            for (int t = 1; t <= test_data_max; ++t) {
                current_statement_begin__ = 72;
                stan::model::assign(test_time_data, 
                            stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                            0, 
                            "assigning variable test_time_data");
            }
            current_statement_begin__ = 73;
            for (int t = 1; t <= generation_max; ++t) {
                current_statement_begin__ = 74;
                for (int td = 1; td <= data_freq; ++td) {
                    current_statement_begin__ = 75;
                    stan::model::assign(test_time_data, 
                                stan::model::cons_list(stan::model::index_uni(((t + td) - 1)), stan::model::nil_index_list()), 
                                (stan::model::rvalue(test_time_data, stan::model::cons_list(stan::model::index_uni(((t + td) - 1)), stan::model::nil_index_list()), "test_time_data") + get_base1(test_time, t, "test_time", 1)), 
                                "assigning variable test_time_data");
                }
            }
            current_statement_begin__ = 76;
            stan::math::assign(test_data_max, ((generation_max + data_freq) - 1));
            current_statement_begin__ = 79;
            stan::math::assign(n_R, ((n_dates - 1) * data_freq));
            current_statement_begin__ = 80;
            stan::math::assign(n_inf, (n_R + generation_max));
            current_statement_begin__ = 81;
            for (int t = 1; t <= n_dates; ++t) {
                current_statement_begin__ = 82;
                stan::model::assign(idx_dp, 
                            stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                            (((t - 1) * data_freq) + generation_max), 
                            "assigning variable idx_dp");
            }
            current_statement_begin__ = 85;
            for (int sdx = 1; sdx <= n_strains; ++sdx) {
                current_statement_begin__ = 86;
                stan::model::assign(inf0_data, 
                            stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list()), 
                            ((get_base1(get_base1(cases, 1, "cases", 1), sdx, "cases", 2) / ascertainment_factor) / data_freq), 
                            "assigning variable inf0_data");
            }
            current_statement_begin__ = 89;
            for (int t = 1; t <= n_dates; ++t) {
                current_statement_begin__ = 90;
                stan::model::assign(ones_dates, 
                            stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                            1, 
                            "assigning variable ones_dates");
            }
            current_statement_begin__ = 93;
            stan::math::assign(n_strain_multipliers, (n_strains - 1));
            current_statement_begin__ = 96;
            for (int sdx = 1; sdx <= n_strains; ++sdx) {

                current_statement_begin__ = 97;
                stan::model::assign(seed_start_time_adj, 
                            stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list()), 
                            (get_base1(seed_start_time, sdx, "seed_start_time", 1) + generation_max), 
                            "assigning variable seed_start_time_adj");
                current_statement_begin__ = 98;
                stan::model::assign(seed_end_time_adj, 
                            stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list()), 
                            (get_base1(seed_end_time, sdx, "seed_end_time", 1) + generation_max), 
                            "assigning variable seed_end_time_adj");
            }
            current_statement_begin__ = 101;
            stan::math::assign(prior_daily_seed_max_max, max(prior_daily_seed_max));
            current_statement_begin__ = 104;
            for (int sdx = 1; sdx <= n_strains; ++sdx) {

                current_statement_begin__ = 105;
                stan::model::assign(n_used_data, 
                            stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list()), 
                            0, 
                            "assigning variable n_used_data");
                current_statement_begin__ = 106;
                for (int t = 1; t <= n_dates; ++t) {

                    current_statement_begin__ = 107;
                    if (as_bool(logical_gte(get_base1(get_base1(cases, t, "cases", 1), sdx, "cases", 2), mask_cases_less_than))) {

                        current_statement_begin__ = 108;
                        stan::model::assign(n_used_data, 
                                    stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list()), 
                                    (stan::model::rvalue(n_used_data, stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list()), "n_used_data") + 1), 
                                    "assigning variable n_used_data");
                        current_statement_begin__ = 109;
                        stan::model::assign(used_data, 
                                    stan::model::cons_list(stan::model::index_uni(get_base1(n_used_data, sdx, "n_used_data", 1)), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                    t, 
                                    "assigning variable used_data");
                    }
                }
            }

            // validate transformed data
            current_statement_begin__ = 43;
            check_greater_or_equal(function__, "n_inf", n_inf, 0);

            current_statement_begin__ = 44;
            check_greater_or_equal(function__, "n_R", n_R, 0);

            current_statement_begin__ = 45;
            check_greater_or_equal(function__, "n_strain_multipliers", n_strain_multipliers, 0);

            current_statement_begin__ = 46;
            check_greater_or_equal(function__, "test_data_max", test_data_max, 0);

            current_statement_begin__ = 47;
            size_t inf0_data_i_0_max__ = n_strains;
            for (size_t i_0__ = 0; i_0__ < inf0_data_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "inf0_data[i_0__]", inf0_data[i_0__], 0);
            }

            current_statement_begin__ = 48;
            size_t idx_dp_i_0_max__ = n_dates;
            for (size_t i_0__ = 0; i_0__ < idx_dp_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "idx_dp[i_0__]", idx_dp[i_0__], 1);
            }

            current_statement_begin__ = 49;
            size_t generation_time_i_0_max__ = generation_max;
            for (size_t i_0__ = 0; i_0__ < generation_time_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "generation_time[i_0__]", generation_time[i_0__], 0);
            }

            current_statement_begin__ = 50;
            size_t test_time_i_0_max__ = generation_max;
            for (size_t i_0__ = 0; i_0__ < test_time_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "test_time[i_0__]", test_time[i_0__], 0);
            }

            current_statement_begin__ = 51;
            size_t test_time_data_i_0_max__ = (generation_max + data_freq);
            for (size_t i_0__ = 0; i_0__ < test_time_data_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "test_time_data[i_0__]", test_time_data[i_0__], 0);
            }

            current_statement_begin__ = 57;
            size_t seed_start_time_adj_i_0_max__ = n_strains;
            for (size_t i_0__ = 0; i_0__ < seed_start_time_adj_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "seed_start_time_adj[i_0__]", seed_start_time_adj[i_0__], 0);
            }

            current_statement_begin__ = 58;
            size_t seed_end_time_adj_i_0_max__ = n_strains;
            for (size_t i_0__ = 0; i_0__ < seed_end_time_adj_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "seed_end_time_adj[i_0__]", seed_end_time_adj[i_0__], 0);
            }

            current_statement_begin__ = 60;
            size_t n_used_data_i_0_max__ = n_strains;
            for (size_t i_0__ = 0; i_0__ < n_used_data_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "n_used_data[i_0__]", n_used_data[i_0__], 0);
            }


            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 118;
            num_params_r__ += 1;
            current_statement_begin__ = 119;
            num_params_r__ += 1;
            current_statement_begin__ = 120;
            validate_non_negative_index("dR", "(n_dates - 1)", (n_dates - 1));
            num_params_r__ += (1 * (n_dates - 1));
            current_statement_begin__ = 121;
            validate_non_negative_index("jumps", "n_jumps", n_jumps);
            num_params_r__ += (1 * n_jumps);
            current_statement_begin__ = 122;
            num_params_r__ += 1;
            current_statement_begin__ = 123;
            validate_non_negative_index("strain_multipliers_raw", "n_strain_multipliers", n_strain_multipliers);
            num_params_r__ += (1 * n_strain_multipliers);
            current_statement_begin__ = 124;
            validate_non_negative_index("daily_seed", "n_strains", n_strains);
            num_params_r__ += (1 * n_strains);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_strain_multiplier() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        typedef double local_scalar_t__;
        stan::io::writer<double> writer__(params_r__, params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        current_statement_begin__ = 118;
        if (!(context__.contains_r("R0")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable R0 missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("R0");
        pos__ = 0U;
        context__.validate_dims("parameter initialization", "R0", "double", context__.to_vec());
        double R0(0);
        R0 = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(prior_R0_min, prior_R0_max, R0);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable R0: ") + e.what()), current_statement_begin__, prog_reader__());
        }

        current_statement_begin__ = 119;
        if (!(context__.contains_r("dR_sd")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable dR_sd missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("dR_sd");
        pos__ = 0U;
        context__.validate_dims("parameter initialization", "dR_sd", "double", context__.to_vec());
        double dR_sd(0);
        dR_sd = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(prior_dR_sd_min, prior_dR_sd_max, dR_sd);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable dR_sd: ") + e.what()), current_statement_begin__, prog_reader__());
        }

        current_statement_begin__ = 120;
        if (!(context__.contains_r("dR")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable dR missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("dR");
        pos__ = 0U;
        validate_non_negative_index("dR", "(n_dates - 1)", (n_dates - 1));
        context__.validate_dims("parameter initialization", "dR", "double", context__.to_vec((n_dates - 1)));
        std::vector<double> dR((n_dates - 1), double(0));
        size_t dR_k_0_max__ = (n_dates - 1);
        for (size_t k_0__ = 0; k_0__ < dR_k_0_max__; ++k_0__) {
            dR[k_0__] = vals_r__[pos__++];
        }
        size_t dR_i_0_max__ = (n_dates - 1);
        for (size_t i_0__ = 0; i_0__ < dR_i_0_max__; ++i_0__) {
            try {
                writer__.scalar_unconstrain(dR[i_0__]);
            } catch (const std::exception& e) {
                stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable dR: ") + e.what()), current_statement_begin__, prog_reader__());
            }
        }

        current_statement_begin__ = 121;
        if (!(context__.contains_r("jumps")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable jumps missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("jumps");
        pos__ = 0U;
        validate_non_negative_index("jumps", "n_jumps", n_jumps);
        context__.validate_dims("parameter initialization", "jumps", "double", context__.to_vec(n_jumps));
        std::vector<double> jumps(n_jumps, double(0));
        size_t jumps_k_0_max__ = n_jumps;
        for (size_t k_0__ = 0; k_0__ < jumps_k_0_max__; ++k_0__) {
            jumps[k_0__] = vals_r__[pos__++];
        }
        size_t jumps_i_0_max__ = n_jumps;
        for (size_t i_0__ = 0; i_0__ < jumps_i_0_max__; ++i_0__) {
            try {
                writer__.scalar_lub_unconstrain(prior_jump_down_max, prior_jump_up_max, jumps[i_0__]);
            } catch (const std::exception& e) {
                stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable jumps: ") + e.what()), current_statement_begin__, prog_reader__());
            }
        }

        current_statement_begin__ = 122;
        if (!(context__.contains_r("phi_od")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable phi_od missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("phi_od");
        pos__ = 0U;
        context__.validate_dims("parameter initialization", "phi_od", "double", context__.to_vec());
        double phi_od(0);
        phi_od = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0, prior_phi_od_max, phi_od);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable phi_od: ") + e.what()), current_statement_begin__, prog_reader__());
        }

        current_statement_begin__ = 123;
        if (!(context__.contains_r("strain_multipliers_raw")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable strain_multipliers_raw missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("strain_multipliers_raw");
        pos__ = 0U;
        validate_non_negative_index("strain_multipliers_raw", "n_strain_multipliers", n_strain_multipliers);
        context__.validate_dims("parameter initialization", "strain_multipliers_raw", "double", context__.to_vec(n_strain_multipliers));
        std::vector<double> strain_multipliers_raw(n_strain_multipliers, double(0));
        size_t strain_multipliers_raw_k_0_max__ = n_strain_multipliers;
        for (size_t k_0__ = 0; k_0__ < strain_multipliers_raw_k_0_max__; ++k_0__) {
            strain_multipliers_raw[k_0__] = vals_r__[pos__++];
        }
        size_t strain_multipliers_raw_i_0_max__ = n_strain_multipliers;
        for (size_t i_0__ = 0; i_0__ < strain_multipliers_raw_i_0_max__; ++i_0__) {
            try {
                writer__.scalar_lub_unconstrain(0, 1, strain_multipliers_raw[i_0__]);
            } catch (const std::exception& e) {
                stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable strain_multipliers_raw: ") + e.what()), current_statement_begin__, prog_reader__());
            }
        }

        current_statement_begin__ = 124;
        if (!(context__.contains_r("daily_seed")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable daily_seed missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("daily_seed");
        pos__ = 0U;
        validate_non_negative_index("daily_seed", "n_strains", n_strains);
        context__.validate_dims("parameter initialization", "daily_seed", "double", context__.to_vec(n_strains));
        std::vector<double> daily_seed(n_strains, double(0));
        size_t daily_seed_k_0_max__ = n_strains;
        for (size_t k_0__ = 0; k_0__ < daily_seed_k_0_max__; ++k_0__) {
            daily_seed[k_0__] = vals_r__[pos__++];
        }
        size_t daily_seed_i_0_max__ = n_strains;
        for (size_t i_0__ = 0; i_0__ < daily_seed_i_0_max__; ++i_0__) {
            try {
                writer__.scalar_lub_unconstrain(0, prior_daily_seed_max_max, daily_seed[i_0__]);
            } catch (const std::exception& e) {
                stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable daily_seed: ") + e.what()), current_statement_begin__, prog_reader__());
            }
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(std::vector<T__>& params_r__,
                 std::vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        typedef T__ local_scalar_t__;

        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // dummy to suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;
        try {
            stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);

            // model parameters
            current_statement_begin__ = 118;
            local_scalar_t__ R0;
            (void) R0;  // dummy to suppress unused var warning
            if (jacobian__)
                R0 = in__.scalar_lub_constrain(prior_R0_min, prior_R0_max, lp__);
            else
                R0 = in__.scalar_lub_constrain(prior_R0_min, prior_R0_max);

            current_statement_begin__ = 119;
            local_scalar_t__ dR_sd;
            (void) dR_sd;  // dummy to suppress unused var warning
            if (jacobian__)
                dR_sd = in__.scalar_lub_constrain(prior_dR_sd_min, prior_dR_sd_max, lp__);
            else
                dR_sd = in__.scalar_lub_constrain(prior_dR_sd_min, prior_dR_sd_max);

            current_statement_begin__ = 120;
            std::vector<local_scalar_t__> dR;
            size_t dR_d_0_max__ = (n_dates - 1);
            dR.reserve(dR_d_0_max__);
            for (size_t d_0__ = 0; d_0__ < dR_d_0_max__; ++d_0__) {
                if (jacobian__)
                    dR.push_back(in__.scalar_constrain(lp__));
                else
                    dR.push_back(in__.scalar_constrain());
            }

            current_statement_begin__ = 121;
            std::vector<local_scalar_t__> jumps;
            size_t jumps_d_0_max__ = n_jumps;
            jumps.reserve(jumps_d_0_max__);
            for (size_t d_0__ = 0; d_0__ < jumps_d_0_max__; ++d_0__) {
                if (jacobian__)
                    jumps.push_back(in__.scalar_lub_constrain(prior_jump_down_max, prior_jump_up_max, lp__));
                else
                    jumps.push_back(in__.scalar_lub_constrain(prior_jump_down_max, prior_jump_up_max));
            }

            current_statement_begin__ = 122;
            local_scalar_t__ phi_od;
            (void) phi_od;  // dummy to suppress unused var warning
            if (jacobian__)
                phi_od = in__.scalar_lub_constrain(0, prior_phi_od_max, lp__);
            else
                phi_od = in__.scalar_lub_constrain(0, prior_phi_od_max);

            current_statement_begin__ = 123;
            std::vector<local_scalar_t__> strain_multipliers_raw;
            size_t strain_multipliers_raw_d_0_max__ = n_strain_multipliers;
            strain_multipliers_raw.reserve(strain_multipliers_raw_d_0_max__);
            for (size_t d_0__ = 0; d_0__ < strain_multipliers_raw_d_0_max__; ++d_0__) {
                if (jacobian__)
                    strain_multipliers_raw.push_back(in__.scalar_lub_constrain(0, 1, lp__));
                else
                    strain_multipliers_raw.push_back(in__.scalar_lub_constrain(0, 1));
            }

            current_statement_begin__ = 124;
            std::vector<local_scalar_t__> daily_seed;
            size_t daily_seed_d_0_max__ = n_strains;
            daily_seed.reserve(daily_seed_d_0_max__);
            for (size_t d_0__ = 0; d_0__ < daily_seed_d_0_max__; ++d_0__) {
                if (jacobian__)
                    daily_seed.push_back(in__.scalar_lub_constrain(0, prior_daily_seed_max_max, lp__));
                else
                    daily_seed.push_back(in__.scalar_lub_constrain(0, prior_daily_seed_max_max));
            }

            // transformed parameters
            current_statement_begin__ = 129;
            validate_non_negative_index("R", "n_R", n_R);
            std::vector<local_scalar_t__> R(n_R, local_scalar_t__(0));
            stan::math::initialize(R, DUMMY_VAR__);
            stan::math::fill(R, DUMMY_VAR__);

            current_statement_begin__ = 130;
            validate_non_negative_index("infections", "n_inf", n_inf);
            validate_non_negative_index("infections", "n_strains", n_strains);
            std::vector<std::vector<local_scalar_t__> > infections(n_inf, std::vector<local_scalar_t__>(n_strains, local_scalar_t__(0)));
            stan::math::initialize(infections, DUMMY_VAR__);
            stan::math::fill(infections, DUMMY_VAR__);

            current_statement_begin__ = 131;
            validate_non_negative_index("cases_expected_dp", "n_dates", n_dates);
            validate_non_negative_index("cases_expected_dp", "n_strains", n_strains);
            std::vector<std::vector<local_scalar_t__> > cases_expected_dp(n_dates, std::vector<local_scalar_t__>(n_strains, local_scalar_t__(0)));
            stan::math::initialize(cases_expected_dp, DUMMY_VAR__);
            stan::math::fill(cases_expected_dp, DUMMY_VAR__);

            current_statement_begin__ = 132;
            validate_non_negative_index("strain_multipliers", "n_strain_multipliers", n_strain_multipliers);
            std::vector<local_scalar_t__> strain_multipliers(n_strain_multipliers, local_scalar_t__(0));
            stan::math::initialize(strain_multipliers, DUMMY_VAR__);
            stan::math::fill(strain_multipliers, DUMMY_VAR__);

            // transformed parameters block statements
            current_statement_begin__ = 135;
            for (int sdx = 1; sdx <= n_strain_multipliers; ++sdx) {
                current_statement_begin__ = 136;
                stan::model::assign(strain_multipliers, 
                            stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list()), 
                            (get_base1(prior_strain_multipliers_min, sdx, "prior_strain_multipliers_min", 1) + ((get_base1(prior_strain_multipliers_max, sdx, "prior_strain_multipliers_max", 1) - get_base1(prior_strain_multipliers_min, sdx, "prior_strain_multipliers_min", 1)) * get_base1(strain_multipliers_raw, sdx, "strain_multipliers_raw", 1))), 
                            "assigning variable strain_multipliers");
            }
            current_statement_begin__ = 139;
            if (as_bool(logical_eq(multiply_strain_multipliers, 1))) {

                current_statement_begin__ = 140;
                for (int sdx = 2; sdx <= n_strain_multipliers; ++sdx) {
                    current_statement_begin__ = 141;
                    stan::model::assign(strain_multipliers, 
                                stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list()), 
                                (get_base1(strain_multipliers, sdx, "strain_multipliers", 1) * get_base1(strain_multipliers, (sdx - 1), "strain_multipliers", 1)), 
                                "assigning variable strain_multipliers");
                }
            }
            current_statement_begin__ = 145;
            for (int idx = 1; idx <= (n_dates - 1); ++idx) {
                current_statement_begin__ = 146;
                for (int jdx = 1; jdx <= data_freq; ++jdx) {
                    current_statement_begin__ = 147;
                    stan::model::assign(R, 
                                stan::model::cons_list(stan::model::index_uni((((idx - 1) * data_freq) + jdx)), stan::model::nil_index_list()), 
                                get_base1(dR, idx, "dR", 1), 
                                "assigning variable R");
                }
            }
            current_statement_begin__ = 148;
            stan::model::assign(R, 
                        stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                        stan::math::log(R0), 
                        "assigning variable R");
            current_statement_begin__ = 149;
            for (int idx = 1; idx <= n_jumps; ++idx) {
                current_statement_begin__ = 150;
                stan::model::assign(R, 
                            stan::model::cons_list(stan::model::index_uni(get_base1(jump_times, idx, "jump_times", 1)), stan::model::nil_index_list()), 
                            stan::math::log(get_base1(jumps, idx, "jumps", 1)), 
                            "assigning variable R");
            }
            current_statement_begin__ = 151;
            stan::math::assign(R, stan::math::exp(cumulative_sum(R)));
            current_statement_begin__ = 154;
            for (int sdx = 1; sdx <= n_strains; ++sdx) {

                current_statement_begin__ = 156;
                for (int t_inf = 1; t_inf <= generation_max; ++t_inf) {
                    current_statement_begin__ = 157;
                    stan::model::assign(infections, 
                                stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                get_base1(inf0_data, sdx, "inf0_data", 1), 
                                "assigning variable infections");
                }
                current_statement_begin__ = 159;
                if (as_bool(logical_gt(get_base1(seed_start_time_adj, sdx, "seed_start_time_adj", 1), generation_max))) {

                    current_statement_begin__ = 161;
                    for (int t_inf = (generation_max + 1); t_inf <= (get_base1(seed_start_time_adj, sdx, "seed_start_time_adj", 1) - 1); ++t_inf) {

                        current_statement_begin__ = 163;
                        stan::model::assign(infections, 
                                    stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                    0, 
                                    "assigning variable infections");
                        current_statement_begin__ = 164;
                        for (int t_g = 1; t_g <= generation_max; ++t_g) {
                            current_statement_begin__ = 165;
                            stan::model::assign(infections, 
                                        stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                        (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") + (get_base1(get_base1(infections, (t_inf - t_g), "infections", 1), sdx, "infections", 2) * get_base1(generation_time, t_g, "generation_time", 1))), 
                                        "assigning variable infections");
                        }
                        current_statement_begin__ = 166;
                        stan::model::assign(infections, 
                                    stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                    (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") * get_base1(R, (t_inf - generation_max), "R", 1)), 
                                    "assigning variable infections");
                        current_statement_begin__ = 167;
                        if (as_bool(logical_gt(sdx, 1))) {
                            current_statement_begin__ = 168;
                            stan::model::assign(infections, 
                                        stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                        (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") * get_base1(strain_multipliers, (sdx - 1), "strain_multipliers", 1)), 
                                        "assigning variable infections");
                        }
                    }
                    current_statement_begin__ = 171;
                    for (int t_inf = get_base1(seed_start_time_adj, sdx, "seed_start_time_adj", 1); t_inf <= get_base1(seed_end_time_adj, sdx, "seed_end_time_adj", 1); ++t_inf) {

                        current_statement_begin__ = 173;
                        stan::model::assign(infections, 
                                    stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                    get_base1(daily_seed, sdx, "daily_seed", 1), 
                                    "assigning variable infections");
                        current_statement_begin__ = 174;
                        for (int t_g = 1; t_g <= generation_max; ++t_g) {
                            current_statement_begin__ = 175;
                            stan::model::assign(infections, 
                                        stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                        (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") + (get_base1(get_base1(infections, (t_inf - t_g), "infections", 1), sdx, "infections", 2) * get_base1(generation_time, t_g, "generation_time", 1))), 
                                        "assigning variable infections");
                        }
                        current_statement_begin__ = 176;
                        stan::model::assign(infections, 
                                    stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                    (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") * get_base1(R, (t_inf - generation_max), "R", 1)), 
                                    "assigning variable infections");
                        current_statement_begin__ = 177;
                        if (as_bool(logical_gt(sdx, 1))) {
                            current_statement_begin__ = 178;
                            stan::model::assign(infections, 
                                        stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                        (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") * get_base1(strain_multipliers, (sdx - 1), "strain_multipliers", 1)), 
                                        "assigning variable infections");
                        }
                    }
                }
                current_statement_begin__ = 182;
                for (int t_inf = (get_base1(seed_end_time_adj, sdx, "seed_end_time_adj", 1) + 1); t_inf <= n_inf; ++t_inf) {

                    current_statement_begin__ = 184;
                    stan::model::assign(infections, 
                                stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                0, 
                                "assigning variable infections");
                    current_statement_begin__ = 185;
                    for (int t_g = 1; t_g <= generation_max; ++t_g) {
                        current_statement_begin__ = 186;
                        stan::model::assign(infections, 
                                    stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                    (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") + (get_base1(get_base1(infections, (t_inf - t_g), "infections", 1), sdx, "infections", 2) * get_base1(generation_time, t_g, "generation_time", 1))), 
                                    "assigning variable infections");
                    }
                    current_statement_begin__ = 187;
                    stan::model::assign(infections, 
                                stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") * get_base1(R, (t_inf - generation_max), "R", 1)), 
                                "assigning variable infections");
                    current_statement_begin__ = 188;
                    if (as_bool(logical_gt(sdx, 1))) {
                        current_statement_begin__ = 189;
                        stan::model::assign(infections, 
                                    stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                    (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") * get_base1(strain_multipliers, (sdx - 1), "strain_multipliers", 1)), 
                                    "assigning variable infections");
                    }
                }
                current_statement_begin__ = 193;
                stan::model::assign(cases_expected_dp, 
                            stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                            stan::math::fmax(get_base1(get_base1(cases, 1, "cases", 1), sdx, "cases", 2), 0.0001), 
                            "assigning variable cases_expected_dp");
                current_statement_begin__ = 194;
                for (int t = 2; t <= n_dates; ++t) {

                    current_statement_begin__ = 196;
                    stan::model::assign(cases_expected_dp, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                0, 
                                "assigning variable cases_expected_dp");
                    current_statement_begin__ = 197;
                    for (int t_g = 1; t_g <= test_data_max; ++t_g) {
                        current_statement_begin__ = 198;
                        stan::model::assign(cases_expected_dp, 
                                    stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                    (stan::model::rvalue(cases_expected_dp, stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "cases_expected_dp") + (get_base1(get_base1(infections, (get_base1(idx_dp, t, "idx_dp", 1) - t_g), "infections", 1), sdx, "infections", 2) * get_base1(test_time_data, t_g, "test_time_data", 1))), 
                                    "assigning variable cases_expected_dp");
                    }
                    current_statement_begin__ = 200;
                    stan::model::assign(cases_expected_dp, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                (stan::model::rvalue(cases_expected_dp, stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "cases_expected_dp") * ascertainment_factor), 
                                "assigning variable cases_expected_dp");
                    current_statement_begin__ = 201;
                    stan::model::assign(cases_expected_dp, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                (stan::model::rvalue(cases_expected_dp, stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "cases_expected_dp") + 0.1), 
                                "assigning variable cases_expected_dp");
                }
            }

            // validate transformed parameters
            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning

            current_statement_begin__ = 129;
            size_t R_k_0_max__ = n_R;
            for (size_t k_0__ = 0; k_0__ < R_k_0_max__; ++k_0__) {
                if (stan::math::is_uninitialized(R[k_0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: R" << "[" << k_0__ << "]";
                    stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable R: ") + msg__.str()), current_statement_begin__, prog_reader__());
                }
            }
            size_t R_i_0_max__ = n_R;
            for (size_t i_0__ = 0; i_0__ < R_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "R[i_0__]", R[i_0__], 0);
            }

            current_statement_begin__ = 130;
            size_t infections_k_0_max__ = n_inf;
            size_t infections_k_1_max__ = n_strains;
            for (size_t k_0__ = 0; k_0__ < infections_k_0_max__; ++k_0__) {
                for (size_t k_1__ = 0; k_1__ < infections_k_1_max__; ++k_1__) {
                    if (stan::math::is_uninitialized(infections[k_0__][k_1__])) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: infections" << "[" << k_0__ << "]" << "[" << k_1__ << "]";
                        stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable infections: ") + msg__.str()), current_statement_begin__, prog_reader__());
                    }
                }
            }
            size_t infections_i_0_max__ = n_inf;
            size_t infections_i_1_max__ = n_strains;
            for (size_t i_0__ = 0; i_0__ < infections_i_0_max__; ++i_0__) {
                for (size_t i_1__ = 0; i_1__ < infections_i_1_max__; ++i_1__) {
                    check_greater_or_equal(function__, "infections[i_0__][i_1__]", infections[i_0__][i_1__], 0);
                }
            }

            current_statement_begin__ = 131;
            size_t cases_expected_dp_k_0_max__ = n_dates;
            size_t cases_expected_dp_k_1_max__ = n_strains;
            for (size_t k_0__ = 0; k_0__ < cases_expected_dp_k_0_max__; ++k_0__) {
                for (size_t k_1__ = 0; k_1__ < cases_expected_dp_k_1_max__; ++k_1__) {
                    if (stan::math::is_uninitialized(cases_expected_dp[k_0__][k_1__])) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: cases_expected_dp" << "[" << k_0__ << "]" << "[" << k_1__ << "]";
                        stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable cases_expected_dp: ") + msg__.str()), current_statement_begin__, prog_reader__());
                    }
                }
            }
            size_t cases_expected_dp_i_0_max__ = n_dates;
            size_t cases_expected_dp_i_1_max__ = n_strains;
            for (size_t i_0__ = 0; i_0__ < cases_expected_dp_i_0_max__; ++i_0__) {
                for (size_t i_1__ = 0; i_1__ < cases_expected_dp_i_1_max__; ++i_1__) {
                    check_greater_or_equal(function__, "cases_expected_dp[i_0__][i_1__]", cases_expected_dp[i_0__][i_1__], 0);
                }
            }

            current_statement_begin__ = 132;
            size_t strain_multipliers_k_0_max__ = n_strain_multipliers;
            for (size_t k_0__ = 0; k_0__ < strain_multipliers_k_0_max__; ++k_0__) {
                if (stan::math::is_uninitialized(strain_multipliers[k_0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: strain_multipliers" << "[" << k_0__ << "]";
                    stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable strain_multipliers: ") + msg__.str()), current_statement_begin__, prog_reader__());
                }
            }
            size_t strain_multipliers_i_0_max__ = n_strain_multipliers;
            for (size_t i_0__ = 0; i_0__ < strain_multipliers_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "strain_multipliers[i_0__]", strain_multipliers[i_0__], 0);
            }


            // model body

            current_statement_begin__ = 214;
            lp_accum__.add(normal_log<propto__>(dR, ((-(0.5) * dR_sd) * dR_sd), dR_sd));
            current_statement_begin__ = 217;
            for (int sdx = 1; sdx <= n_strains; ++sdx) {

                current_statement_begin__ = 218;
                lp_accum__.add(neg_binomial_2_log<propto__>(stan::model::rvalue(cases, stan::model::cons_list(stan::model::index_multi(stan::model::rvalue(used_data, stan::model::cons_list(stan::model::index_min_max(1, get_base1(n_used_data, sdx, "n_used_data", 1)), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "used_data")), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "cases"), stan::model::rvalue(cases_expected_dp, stan::model::cons_list(stan::model::index_multi(stan::model::rvalue(used_data, stan::model::cons_list(stan::model::index_min_max(1, get_base1(n_used_data, sdx, "n_used_data", 1)), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "used_data")), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "cases_expected_dp"), divide(stan::model::rvalue(ones_dates, stan::model::cons_list(stan::model::index_min_max(1, get_base1(n_used_data, sdx, "n_used_data", 1)), stan::model::nil_index_list()), "ones_dates"), phi_od)));
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("R0");
        names__.push_back("dR_sd");
        names__.push_back("dR");
        names__.push_back("jumps");
        names__.push_back("phi_od");
        names__.push_back("strain_multipliers_raw");
        names__.push_back("daily_seed");
        names__.push_back("R");
        names__.push_back("infections");
        names__.push_back("cases_expected_dp");
        names__.push_back("strain_multipliers");
        names__.push_back("R_comb");
        names__.push_back("R_denom");
        names__.push_back("R_numer");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((n_dates - 1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_jumps);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_strain_multipliers);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_strains);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_R);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_inf);
        dims__.push_back(n_strains);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_dates);
        dims__.push_back(n_strains);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_strain_multipliers);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_R);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        typedef double local_scalar_t__;

        vars__.resize(0);
        stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
        static const char* function__ = "model_strain_multiplier_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning

        // read-transform, write parameters
        double R0 = in__.scalar_lub_constrain(prior_R0_min, prior_R0_max);
        vars__.push_back(R0);

        double dR_sd = in__.scalar_lub_constrain(prior_dR_sd_min, prior_dR_sd_max);
        vars__.push_back(dR_sd);

        std::vector<double> dR;
        size_t dR_d_0_max__ = (n_dates - 1);
        dR.reserve(dR_d_0_max__);
        for (size_t d_0__ = 0; d_0__ < dR_d_0_max__; ++d_0__) {
            dR.push_back(in__.scalar_constrain());
        }
        size_t dR_k_0_max__ = (n_dates - 1);
        for (size_t k_0__ = 0; k_0__ < dR_k_0_max__; ++k_0__) {
            vars__.push_back(dR[k_0__]);
        }

        std::vector<double> jumps;
        size_t jumps_d_0_max__ = n_jumps;
        jumps.reserve(jumps_d_0_max__);
        for (size_t d_0__ = 0; d_0__ < jumps_d_0_max__; ++d_0__) {
            jumps.push_back(in__.scalar_lub_constrain(prior_jump_down_max, prior_jump_up_max));
        }
        size_t jumps_k_0_max__ = n_jumps;
        for (size_t k_0__ = 0; k_0__ < jumps_k_0_max__; ++k_0__) {
            vars__.push_back(jumps[k_0__]);
        }

        double phi_od = in__.scalar_lub_constrain(0, prior_phi_od_max);
        vars__.push_back(phi_od);

        std::vector<double> strain_multipliers_raw;
        size_t strain_multipliers_raw_d_0_max__ = n_strain_multipliers;
        strain_multipliers_raw.reserve(strain_multipliers_raw_d_0_max__);
        for (size_t d_0__ = 0; d_0__ < strain_multipliers_raw_d_0_max__; ++d_0__) {
            strain_multipliers_raw.push_back(in__.scalar_lub_constrain(0, 1));
        }
        size_t strain_multipliers_raw_k_0_max__ = n_strain_multipliers;
        for (size_t k_0__ = 0; k_0__ < strain_multipliers_raw_k_0_max__; ++k_0__) {
            vars__.push_back(strain_multipliers_raw[k_0__]);
        }

        std::vector<double> daily_seed;
        size_t daily_seed_d_0_max__ = n_strains;
        daily_seed.reserve(daily_seed_d_0_max__);
        for (size_t d_0__ = 0; d_0__ < daily_seed_d_0_max__; ++d_0__) {
            daily_seed.push_back(in__.scalar_lub_constrain(0, prior_daily_seed_max_max));
        }
        size_t daily_seed_k_0_max__ = n_strains;
        for (size_t k_0__ = 0; k_0__ < daily_seed_k_0_max__; ++k_0__) {
            vars__.push_back(daily_seed[k_0__]);
        }

        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        if (!include_tparams__ && !include_gqs__) return;

        try {
            // declare and define transformed parameters
            current_statement_begin__ = 129;
            validate_non_negative_index("R", "n_R", n_R);
            std::vector<double> R(n_R, double(0));
            stan::math::initialize(R, DUMMY_VAR__);
            stan::math::fill(R, DUMMY_VAR__);

            current_statement_begin__ = 130;
            validate_non_negative_index("infections", "n_inf", n_inf);
            validate_non_negative_index("infections", "n_strains", n_strains);
            std::vector<std::vector<double> > infections(n_inf, std::vector<double>(n_strains, double(0)));
            stan::math::initialize(infections, DUMMY_VAR__);
            stan::math::fill(infections, DUMMY_VAR__);

            current_statement_begin__ = 131;
            validate_non_negative_index("cases_expected_dp", "n_dates", n_dates);
            validate_non_negative_index("cases_expected_dp", "n_strains", n_strains);
            std::vector<std::vector<double> > cases_expected_dp(n_dates, std::vector<double>(n_strains, double(0)));
            stan::math::initialize(cases_expected_dp, DUMMY_VAR__);
            stan::math::fill(cases_expected_dp, DUMMY_VAR__);

            current_statement_begin__ = 132;
            validate_non_negative_index("strain_multipliers", "n_strain_multipliers", n_strain_multipliers);
            std::vector<double> strain_multipliers(n_strain_multipliers, double(0));
            stan::math::initialize(strain_multipliers, DUMMY_VAR__);
            stan::math::fill(strain_multipliers, DUMMY_VAR__);

            // do transformed parameters statements
            current_statement_begin__ = 135;
            for (int sdx = 1; sdx <= n_strain_multipliers; ++sdx) {
                current_statement_begin__ = 136;
                stan::model::assign(strain_multipliers, 
                            stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list()), 
                            (get_base1(prior_strain_multipliers_min, sdx, "prior_strain_multipliers_min", 1) + ((get_base1(prior_strain_multipliers_max, sdx, "prior_strain_multipliers_max", 1) - get_base1(prior_strain_multipliers_min, sdx, "prior_strain_multipliers_min", 1)) * get_base1(strain_multipliers_raw, sdx, "strain_multipliers_raw", 1))), 
                            "assigning variable strain_multipliers");
            }
            current_statement_begin__ = 139;
            if (as_bool(logical_eq(multiply_strain_multipliers, 1))) {

                current_statement_begin__ = 140;
                for (int sdx = 2; sdx <= n_strain_multipliers; ++sdx) {
                    current_statement_begin__ = 141;
                    stan::model::assign(strain_multipliers, 
                                stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list()), 
                                (get_base1(strain_multipliers, sdx, "strain_multipliers", 1) * get_base1(strain_multipliers, (sdx - 1), "strain_multipliers", 1)), 
                                "assigning variable strain_multipliers");
                }
            }
            current_statement_begin__ = 145;
            for (int idx = 1; idx <= (n_dates - 1); ++idx) {
                current_statement_begin__ = 146;
                for (int jdx = 1; jdx <= data_freq; ++jdx) {
                    current_statement_begin__ = 147;
                    stan::model::assign(R, 
                                stan::model::cons_list(stan::model::index_uni((((idx - 1) * data_freq) + jdx)), stan::model::nil_index_list()), 
                                get_base1(dR, idx, "dR", 1), 
                                "assigning variable R");
                }
            }
            current_statement_begin__ = 148;
            stan::model::assign(R, 
                        stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                        stan::math::log(R0), 
                        "assigning variable R");
            current_statement_begin__ = 149;
            for (int idx = 1; idx <= n_jumps; ++idx) {
                current_statement_begin__ = 150;
                stan::model::assign(R, 
                            stan::model::cons_list(stan::model::index_uni(get_base1(jump_times, idx, "jump_times", 1)), stan::model::nil_index_list()), 
                            stan::math::log(get_base1(jumps, idx, "jumps", 1)), 
                            "assigning variable R");
            }
            current_statement_begin__ = 151;
            stan::math::assign(R, stan::math::exp(cumulative_sum(R)));
            current_statement_begin__ = 154;
            for (int sdx = 1; sdx <= n_strains; ++sdx) {

                current_statement_begin__ = 156;
                for (int t_inf = 1; t_inf <= generation_max; ++t_inf) {
                    current_statement_begin__ = 157;
                    stan::model::assign(infections, 
                                stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                get_base1(inf0_data, sdx, "inf0_data", 1), 
                                "assigning variable infections");
                }
                current_statement_begin__ = 159;
                if (as_bool(logical_gt(get_base1(seed_start_time_adj, sdx, "seed_start_time_adj", 1), generation_max))) {

                    current_statement_begin__ = 161;
                    for (int t_inf = (generation_max + 1); t_inf <= (get_base1(seed_start_time_adj, sdx, "seed_start_time_adj", 1) - 1); ++t_inf) {

                        current_statement_begin__ = 163;
                        stan::model::assign(infections, 
                                    stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                    0, 
                                    "assigning variable infections");
                        current_statement_begin__ = 164;
                        for (int t_g = 1; t_g <= generation_max; ++t_g) {
                            current_statement_begin__ = 165;
                            stan::model::assign(infections, 
                                        stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                        (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") + (get_base1(get_base1(infections, (t_inf - t_g), "infections", 1), sdx, "infections", 2) * get_base1(generation_time, t_g, "generation_time", 1))), 
                                        "assigning variable infections");
                        }
                        current_statement_begin__ = 166;
                        stan::model::assign(infections, 
                                    stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                    (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") * get_base1(R, (t_inf - generation_max), "R", 1)), 
                                    "assigning variable infections");
                        current_statement_begin__ = 167;
                        if (as_bool(logical_gt(sdx, 1))) {
                            current_statement_begin__ = 168;
                            stan::model::assign(infections, 
                                        stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                        (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") * get_base1(strain_multipliers, (sdx - 1), "strain_multipliers", 1)), 
                                        "assigning variable infections");
                        }
                    }
                    current_statement_begin__ = 171;
                    for (int t_inf = get_base1(seed_start_time_adj, sdx, "seed_start_time_adj", 1); t_inf <= get_base1(seed_end_time_adj, sdx, "seed_end_time_adj", 1); ++t_inf) {

                        current_statement_begin__ = 173;
                        stan::model::assign(infections, 
                                    stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                    get_base1(daily_seed, sdx, "daily_seed", 1), 
                                    "assigning variable infections");
                        current_statement_begin__ = 174;
                        for (int t_g = 1; t_g <= generation_max; ++t_g) {
                            current_statement_begin__ = 175;
                            stan::model::assign(infections, 
                                        stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                        (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") + (get_base1(get_base1(infections, (t_inf - t_g), "infections", 1), sdx, "infections", 2) * get_base1(generation_time, t_g, "generation_time", 1))), 
                                        "assigning variable infections");
                        }
                        current_statement_begin__ = 176;
                        stan::model::assign(infections, 
                                    stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                    (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") * get_base1(R, (t_inf - generation_max), "R", 1)), 
                                    "assigning variable infections");
                        current_statement_begin__ = 177;
                        if (as_bool(logical_gt(sdx, 1))) {
                            current_statement_begin__ = 178;
                            stan::model::assign(infections, 
                                        stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                        (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") * get_base1(strain_multipliers, (sdx - 1), "strain_multipliers", 1)), 
                                        "assigning variable infections");
                        }
                    }
                }
                current_statement_begin__ = 182;
                for (int t_inf = (get_base1(seed_end_time_adj, sdx, "seed_end_time_adj", 1) + 1); t_inf <= n_inf; ++t_inf) {

                    current_statement_begin__ = 184;
                    stan::model::assign(infections, 
                                stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                0, 
                                "assigning variable infections");
                    current_statement_begin__ = 185;
                    for (int t_g = 1; t_g <= generation_max; ++t_g) {
                        current_statement_begin__ = 186;
                        stan::model::assign(infections, 
                                    stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                    (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") + (get_base1(get_base1(infections, (t_inf - t_g), "infections", 1), sdx, "infections", 2) * get_base1(generation_time, t_g, "generation_time", 1))), 
                                    "assigning variable infections");
                    }
                    current_statement_begin__ = 187;
                    stan::model::assign(infections, 
                                stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") * get_base1(R, (t_inf - generation_max), "R", 1)), 
                                "assigning variable infections");
                    current_statement_begin__ = 188;
                    if (as_bool(logical_gt(sdx, 1))) {
                        current_statement_begin__ = 189;
                        stan::model::assign(infections, 
                                    stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                    (stan::model::rvalue(infections, stan::model::cons_list(stan::model::index_uni(t_inf), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "infections") * get_base1(strain_multipliers, (sdx - 1), "strain_multipliers", 1)), 
                                    "assigning variable infections");
                    }
                }
                current_statement_begin__ = 193;
                stan::model::assign(cases_expected_dp, 
                            stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                            stan::math::fmax(get_base1(get_base1(cases, 1, "cases", 1), sdx, "cases", 2), 0.0001), 
                            "assigning variable cases_expected_dp");
                current_statement_begin__ = 194;
                for (int t = 2; t <= n_dates; ++t) {

                    current_statement_begin__ = 196;
                    stan::model::assign(cases_expected_dp, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                0, 
                                "assigning variable cases_expected_dp");
                    current_statement_begin__ = 197;
                    for (int t_g = 1; t_g <= test_data_max; ++t_g) {
                        current_statement_begin__ = 198;
                        stan::model::assign(cases_expected_dp, 
                                    stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                    (stan::model::rvalue(cases_expected_dp, stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "cases_expected_dp") + (get_base1(get_base1(infections, (get_base1(idx_dp, t, "idx_dp", 1) - t_g), "infections", 1), sdx, "infections", 2) * get_base1(test_time_data, t_g, "test_time_data", 1))), 
                                    "assigning variable cases_expected_dp");
                    }
                    current_statement_begin__ = 200;
                    stan::model::assign(cases_expected_dp, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                (stan::model::rvalue(cases_expected_dp, stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "cases_expected_dp") * ascertainment_factor), 
                                "assigning variable cases_expected_dp");
                    current_statement_begin__ = 201;
                    stan::model::assign(cases_expected_dp, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), 
                                (stan::model::rvalue(cases_expected_dp, stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(sdx), stan::model::nil_index_list())), "cases_expected_dp") + 0.1), 
                                "assigning variable cases_expected_dp");
                }
            }

            if (!include_gqs__ && !include_tparams__) return;
            // validate transformed parameters
            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning

            current_statement_begin__ = 129;
            size_t R_i_0_max__ = n_R;
            for (size_t i_0__ = 0; i_0__ < R_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "R[i_0__]", R[i_0__], 0);
            }

            current_statement_begin__ = 130;
            size_t infections_i_0_max__ = n_inf;
            size_t infections_i_1_max__ = n_strains;
            for (size_t i_0__ = 0; i_0__ < infections_i_0_max__; ++i_0__) {
                for (size_t i_1__ = 0; i_1__ < infections_i_1_max__; ++i_1__) {
                    check_greater_or_equal(function__, "infections[i_0__][i_1__]", infections[i_0__][i_1__], 0);
                }
            }

            current_statement_begin__ = 131;
            size_t cases_expected_dp_i_0_max__ = n_dates;
            size_t cases_expected_dp_i_1_max__ = n_strains;
            for (size_t i_0__ = 0; i_0__ < cases_expected_dp_i_0_max__; ++i_0__) {
                for (size_t i_1__ = 0; i_1__ < cases_expected_dp_i_1_max__; ++i_1__) {
                    check_greater_or_equal(function__, "cases_expected_dp[i_0__][i_1__]", cases_expected_dp[i_0__][i_1__], 0);
                }
            }

            current_statement_begin__ = 132;
            size_t strain_multipliers_i_0_max__ = n_strain_multipliers;
            for (size_t i_0__ = 0; i_0__ < strain_multipliers_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "strain_multipliers[i_0__]", strain_multipliers[i_0__], 0);
            }

            // write transformed parameters
            if (include_tparams__) {
                size_t R_k_0_max__ = n_R;
                for (size_t k_0__ = 0; k_0__ < R_k_0_max__; ++k_0__) {
                    vars__.push_back(R[k_0__]);
                }
                size_t infections_k_0_max__ = n_inf;
                size_t infections_k_1_max__ = n_strains;
                for (size_t k_1__ = 0; k_1__ < infections_k_1_max__; ++k_1__) {
                    for (size_t k_0__ = 0; k_0__ < infections_k_0_max__; ++k_0__) {
                        vars__.push_back(infections[k_0__][k_1__]);
                    }
                }
                size_t cases_expected_dp_k_0_max__ = n_dates;
                size_t cases_expected_dp_k_1_max__ = n_strains;
                for (size_t k_1__ = 0; k_1__ < cases_expected_dp_k_1_max__; ++k_1__) {
                    for (size_t k_0__ = 0; k_0__ < cases_expected_dp_k_0_max__; ++k_0__) {
                        vars__.push_back(cases_expected_dp[k_0__][k_1__]);
                    }
                }
                size_t strain_multipliers_k_0_max__ = n_strain_multipliers;
                for (size_t k_0__ = 0; k_0__ < strain_multipliers_k_0_max__; ++k_0__) {
                    vars__.push_back(strain_multipliers[k_0__]);
                }
            }
            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 224;
            validate_non_negative_index("R_comb", "n_R", n_R);
            std::vector<double> R_comb(n_R, double(0));
            stan::math::initialize(R_comb, DUMMY_VAR__);
            stan::math::fill(R_comb, DUMMY_VAR__);

            current_statement_begin__ = 225;
            double R_denom;
            (void) R_denom;  // dummy to suppress unused var warning
            stan::math::initialize(R_denom, DUMMY_VAR__);
            stan::math::fill(R_denom, DUMMY_VAR__);

            current_statement_begin__ = 226;
            double R_numer;
            (void) R_numer;  // dummy to suppress unused var warning
            stan::math::initialize(R_numer, DUMMY_VAR__);
            stan::math::fill(R_numer, DUMMY_VAR__);

            // generated quantities statements
            current_statement_begin__ = 229;
            for (int t_inf = (generation_max + 1); t_inf <= n_inf; ++t_inf) {

                current_statement_begin__ = 231;
                stan::math::assign(R_denom, get_base1(get_base1(infections, t_inf, "infections", 1), 1, "infections", 2));
                current_statement_begin__ = 232;
                stan::math::assign(R_numer, get_base1(get_base1(infections, t_inf, "infections", 1), 1, "infections", 2));
                current_statement_begin__ = 233;
                for (int sdx = 2; sdx <= n_strains; ++sdx) {

                    current_statement_begin__ = 234;
                    stan::math::assign(R_denom, (R_denom + (get_base1(get_base1(infections, t_inf, "infections", 1), sdx, "infections", 2) / get_base1(strain_multipliers, (sdx - 1), "strain_multipliers", 1))));
                    current_statement_begin__ = 235;
                    stan::math::assign(R_numer, (R_numer + get_base1(get_base1(infections, t_inf, "infections", 1), sdx, "infections", 2)));
                }
                current_statement_begin__ = 237;
                stan::model::assign(R_comb, 
                            stan::model::cons_list(stan::model::index_uni((t_inf - generation_max)), stan::model::nil_index_list()), 
                            ((get_base1(R, (t_inf - generation_max), "R", 1) * R_numer) / R_denom), 
                            "assigning variable R_comb");
            }

            // validate, write generated quantities
            current_statement_begin__ = 224;
            size_t R_comb_i_0_max__ = n_R;
            for (size_t i_0__ = 0; i_0__ < R_comb_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "R_comb[i_0__]", R_comb[i_0__], 0);
            }

            size_t R_comb_k_0_max__ = n_R;
            for (size_t k_0__ = 0; k_0__ < R_comb_k_0_max__; ++k_0__) {
                vars__.push_back(R_comb[k_0__]);
            }

            current_statement_begin__ = 225;
            check_greater_or_equal(function__, "R_denom", R_denom, 0);

            vars__.push_back(R_denom);

            current_statement_begin__ = 226;
            check_greater_or_equal(function__, "R_numer", R_numer, 0);

            vars__.push_back(R_numer);

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng, params_r_vec, params_i_vec, vars_vec, include_tparams, include_gqs, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    std::string model_name() const {
        return "model_strain_multiplier";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "R0";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "dR_sd";
        param_names__.push_back(param_name_stream__.str());
        size_t dR_k_0_max__ = (n_dates - 1);
        for (size_t k_0__ = 0; k_0__ < dR_k_0_max__; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "dR" << '.' << k_0__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t jumps_k_0_max__ = n_jumps;
        for (size_t k_0__ = 0; k_0__ < jumps_k_0_max__; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "jumps" << '.' << k_0__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "phi_od";
        param_names__.push_back(param_name_stream__.str());
        size_t strain_multipliers_raw_k_0_max__ = n_strain_multipliers;
        for (size_t k_0__ = 0; k_0__ < strain_multipliers_raw_k_0_max__; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "strain_multipliers_raw" << '.' << k_0__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t daily_seed_k_0_max__ = n_strains;
        for (size_t k_0__ = 0; k_0__ < daily_seed_k_0_max__; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "daily_seed" << '.' << k_0__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;

        if (include_tparams__) {
            size_t R_k_0_max__ = n_R;
            for (size_t k_0__ = 0; k_0__ < R_k_0_max__; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "R" << '.' << k_0__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t infections_k_0_max__ = n_inf;
            size_t infections_k_1_max__ = n_strains;
            for (size_t k_1__ = 0; k_1__ < infections_k_1_max__; ++k_1__) {
                for (size_t k_0__ = 0; k_0__ < infections_k_0_max__; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "infections" << '.' << k_0__ + 1 << '.' << k_1__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t cases_expected_dp_k_0_max__ = n_dates;
            size_t cases_expected_dp_k_1_max__ = n_strains;
            for (size_t k_1__ = 0; k_1__ < cases_expected_dp_k_1_max__; ++k_1__) {
                for (size_t k_0__ = 0; k_0__ < cases_expected_dp_k_0_max__; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "cases_expected_dp" << '.' << k_0__ + 1 << '.' << k_1__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t strain_multipliers_k_0_max__ = n_strain_multipliers;
            for (size_t k_0__ = 0; k_0__ < strain_multipliers_k_0_max__; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "strain_multipliers" << '.' << k_0__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__) return;
        size_t R_comb_k_0_max__ = n_R;
        for (size_t k_0__ = 0; k_0__ < R_comb_k_0_max__; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R_comb" << '.' << k_0__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "R_denom";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "R_numer";
        param_names__.push_back(param_name_stream__.str());
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "R0";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "dR_sd";
        param_names__.push_back(param_name_stream__.str());
        size_t dR_k_0_max__ = (n_dates - 1);
        for (size_t k_0__ = 0; k_0__ < dR_k_0_max__; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "dR" << '.' << k_0__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t jumps_k_0_max__ = n_jumps;
        for (size_t k_0__ = 0; k_0__ < jumps_k_0_max__; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "jumps" << '.' << k_0__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "phi_od";
        param_names__.push_back(param_name_stream__.str());
        size_t strain_multipliers_raw_k_0_max__ = n_strain_multipliers;
        for (size_t k_0__ = 0; k_0__ < strain_multipliers_raw_k_0_max__; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "strain_multipliers_raw" << '.' << k_0__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t daily_seed_k_0_max__ = n_strains;
        for (size_t k_0__ = 0; k_0__ < daily_seed_k_0_max__; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "daily_seed" << '.' << k_0__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;

        if (include_tparams__) {
            size_t R_k_0_max__ = n_R;
            for (size_t k_0__ = 0; k_0__ < R_k_0_max__; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "R" << '.' << k_0__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t infections_k_0_max__ = n_inf;
            size_t infections_k_1_max__ = n_strains;
            for (size_t k_1__ = 0; k_1__ < infections_k_1_max__; ++k_1__) {
                for (size_t k_0__ = 0; k_0__ < infections_k_0_max__; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "infections" << '.' << k_0__ + 1 << '.' << k_1__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t cases_expected_dp_k_0_max__ = n_dates;
            size_t cases_expected_dp_k_1_max__ = n_strains;
            for (size_t k_1__ = 0; k_1__ < cases_expected_dp_k_1_max__; ++k_1__) {
                for (size_t k_0__ = 0; k_0__ < cases_expected_dp_k_0_max__; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "cases_expected_dp" << '.' << k_0__ + 1 << '.' << k_1__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t strain_multipliers_k_0_max__ = n_strain_multipliers;
            for (size_t k_0__ = 0; k_0__ < strain_multipliers_k_0_max__; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "strain_multipliers" << '.' << k_0__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__) return;
        size_t R_comb_k_0_max__ = n_R;
        for (size_t k_0__ = 0; k_0__ < R_comb_k_0_max__; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "R_comb" << '.' << k_0__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "R_denom";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "R_numer";
        param_names__.push_back(param_name_stream__.str());
    }

}; // model

}  // namespace

typedef model_strain_multiplier_namespace::model_strain_multiplier stan_model;

#ifndef USING_R

stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif


#endif
